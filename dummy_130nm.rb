#!/usr/bin/ruby
## pipo.rb is used with cadence Virtuoso
## to stream in and out GDS and layout database
## Make sure to source cadence license file beforehand

require 'optparse'
require 'pp'


class Dummy

  def self.get_lines(filename)
    return File.open(filename, 'r').readlines
  end  
  
  def self.parse(args)
    # The options specified on the command line will be collected in *options*.
    # We set default values here.
    
    options = {}

    optparse = OptionParser.new do |opts|
      opts.banner = "Usage: dummy.rb -t topcell -x x1y1x2y2 [options] <path/>input.gds"

      options[:top] = nil
      opts.on("-t", "--top CellName", "GDS top cell. Default <input>") do |top|
        options[:top] = top
      end
      
      # Process: 1. 1P6M1T40KA (tuner); 2. 1P6M1T8KA (no tuner)
      options[:process] = 1
      opts.on("-p", "--process N", Integer, "1:1P6M1T40KA/tuner  2.1P6M1T8KA/normal. Default=1") do |no|
        options[:process] = no
      end
      
      # X1Y1X2Y2 coordinate
      options[:x1y1x2y2] = ["0","0","100","100"]
      opts.on("-x", "--x1y1x2y2 x1,x2,y1,y2", Array, "Dummy area <x1,y1> to <x2,y2>") do |xy|
        options[:x1y1x2y2] = xy
      end

      options[:rundrc] = "rundrc"
      opts.on("-d", "--drc rundrc", "Ouput DRC shell command. Default \"rundrc\"") do |dd|
        options[:rundrc] = dd
      end
      
      # Boolean switch.
      #options[:verbose] = false
      #opts.on("-v", "--verbose", "Run verbosely") do |v|
      #  options[:verbose] = true
      #end
      
      opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        exit
      end
      
    end
    
    optparse.parse!(args)
    pp args if @debug
    if args.length == 0
      puts optparse
      exit
    else
      options[:inGDS] = args[0]  ## remaining args[0] is path/input.gds
    end
    return options
  end  # parse()


  ########################################################################
  #### main starts here

  @debug = false

  #### option parse
  options = Dummy.parse(ARGV)
  pp options if @debug


  ##### INPUT raw GDS file without dummy and top cell name (Change based on design)
  inGDS = options[:inGDS]
  if options[:top] == nil
    topCellName = File.basename(inGDS, File.extname(inGDS))
  else
    topCellName = options[:top]
  end
  pp topCellName if @debug

  ## INPUT design origin coordinate (Change based on design)
  windowX1Y1X2Y2 = options[:x1y1x2y2].collect{|x| x.to_f}

  #----- First, process metal dummy --------

  #### INPUT metal dummy GDS pattern GDS file (Do NOT change)
  #dummyMetalGDS = "/home/atd/tech/110nm/umc/dummy_slot/curr/110_AL_metal/umc_dummy_slot.gds"
  dummyMetalGDS = "/home/atd/tech/130nm/umc/dummy_slot/curr/L130_metal/umc_dummy_slot.gds"

  ## INPUT metal dummy DRC including path (Do NOT change)
  #dummyMetalDRCDir = "/home/atd/tech/110nm/umc/dummy_slot/curr/110_AL_metal/"
  dummyMetalDRCDir = "/home/atd/tech/130nm/umc/dummy_slot/curr/L130_metal/"
  
  ## INPUT metal dummy master DRC file (Do NOT change)
  #dummyMetalMasterDRC = "#{dummyMetalDRCDir}110_AL_METAL_mainchip_dummy.drc"
  dummyMetalMasterDRC = "#{dummyMetalDRCDir}L130_METAL_dummy.drc"

  ## INPUT metal dummy Include DRC files (Change based on process, metal layer and thin/thick)
  if options[:process] == 1   ## 1P7M2T20KA/tuner
    dummyMetalIncDRCHash = {
      "m1dmy" => "#{dummyMetalDRCDir}L130_m1dummy_thin.drc",
      "m2dmy" => "#{dummyMetalDRCDir}L130_m2dummy_thin.drc",
      "m3dmy" => "#{dummyMetalDRCDir}L130_m3dummy_thin.drc",
      "m4dmy" => "#{dummyMetalDRCDir}L130_m4dummy_thin.drc",
      "m5dmy" => "#{dummyMetalDRCDir}L130_m5dummy_thin.drc",
      "m6dmy" => "#{dummyMetalDRCDir}L130_m6dummy_thick.drc",
      "m7dmy" => "#{dummyMetalDRCDir}L130_m7dummy_thick_20KA.drc"
    }

    ## OUTPUT dummy GDS files generated by Calibre (Change based on process, metal layer)
    dummyGDSHash = {
      "m1dmy" => "#{topCellName}_m1dmy.gds",
      "m2dmy" => "#{topCellName}_m2dmy.gds",
      "m3dmy" => "#{topCellName}_m3dmy.gds",
      "m4dmy" => "#{topCellName}_m4dmy.gds",
      "m5dmy" => "#{topCellName}_m5dmy.gds",
      "m6dmy" => "#{topCellName}_m6dmy.gds",
      "m7dmy" => "#{topCellName}_m7dmy.gds"
    }

  else  ## 1P6M1T/normal (use the same metal, ignore the last 20KA dummy layer!
    dummyMetalIncDRCHash = {
      "m1dmy" => "#{dummyMetalDRCDir}L130_m1dummy_thin.drc",
      "m2dmy" => "#{dummyMetalDRCDir}L130_m2dummy_thin.drc",
      "m3dmy" => "#{dummyMetalDRCDir}L130_m3dummy_thin.drc",
      "m4dmy" => "#{dummyMetalDRCDir}L130_m4dummy_thin.drc",
      "m5dmy" => "#{dummyMetalDRCDir}L130_m5dummy_thin.drc",
      "m6dmy" => "#{dummyMetalDRCDir}L130_m6dummy_thick.drc",
      "m7dmy" => "#{dummyMetalDRCDir}L130_m7dummy_thick_20KA.drc"
    }

    ## OUTPUT dummy GDS files generated by Calibre (Change based on process, metal layer)
    dummyGDSHash = {
      "m1dmy" => "#{topCellName}_m1dmy.gds",
      "m2dmy" => "#{topCellName}_m2dmy.gds",
      "m3dmy" => "#{topCellName}_m3dmy.gds",
      "m4dmy" => "#{topCellName}_m4dmy.gds",
      "m5dmy" => "#{topCellName}_m5dmy.gds",
      "m6dmy" => "#{topCellName}_m6dmy.gds",
      "m7dmy" => "#{topCellName}_m7dmy.gds"
    }

  end


  ## sorted by key
  dummyDRCarr = []
  dummyMetalIncDRCHash.sort.map do |key, incDRC|

    mergeDRCList = [dummyMetalMasterDRC, incDRC ]  ## merge Master DRC + Inc DRC
    
    ## merge Master DRC + Inc DRC into a raw DRC
    mergeDRC = "#{topCellName}_#{key}.drc.raw"
    File.open(mergeDRC, "w") { |f|
      f.puts mergeDRCList.map{|s| IO.read(s)} }
    
    ## process raw drc file and generate final drc file
    finalDRC = "#{topCellName}_#{key}.drc"
    dummyDRCarr << finalDRC   ## for later rundrc purpose
    ff = File.new(finalDRC, "w")

    get_lines(mergeDRC).each_with_index do |line, line_no|
      line.gsub!(/^\s*LAYOUT\s+PATH\s+.*$/i, "LAYOUT PATH \"#{inGDS}\"")
      line.gsub!(/^\s*LAYOUT\s+PRIMARY\s+.*$/i, "LAYOUT PRIMARY \"#{topCellName}\"")
      line.gsub!(/^\s*DRC\s+RESULTS\s+DATABASE\s+.*$/i, "DRC RESULTS DATABASE \"#{dummyGDSHash[key]}\" GDSII PSEUDO")
      line.gsub!(/^\s*DRC\s+SUMMARY\s+REPORT\s+.*$/i, "DRC SUMMARY REPORT \"#{dummyGDSHash[key]}.sum\"")
      line.gsub!(/^\s*LAYOUT\s+WINDOW\s+.*PLEASE.*$/i, "LAYOUT WINDOW #{windowX1Y1X2Y2.join(' ')}")
      line.gsub!(/^\s*POLYGON\s+.*$/i, "POLYGON #{windowX1Y1X2Y2.join(' ')} BULKALL")
      line.gsub!(/^\s*LAYOUT\s+PATH2\s+.*$/i, "LAYOUT PATH2 \"#{dummyMetalGDS}\"")

      ff.print(line)
    end
    
  end # dummyMetalIncDRCHash


  #----- Second, process poly/diff dummy --------


  #### INPUT poly/diffusion dummy GDS pattern GDS file; seems same as metal dummy (Do NOT change)
  #dummyPolyGDS = "/home/atd/tech/110nm/umc/dummy_slot/curr/110_AL_diffusion_poly1/umc_dummy_slot.gds"
  dummyPolyGDS = "/home/atd/tech/130nm/umc/dummy_slot/curr/L130_beyond_diffusion_poly1/umc_dummy_slot.gds"

  ## INPUT poly/diff dummy DRC (Do NOT change)
  #dummyPolyDRC = "/home/atd/tech/110nm/umc/dummy_slot/curr/110_AL_diffusion_poly1/DIFFUSION_POLY1_dummy.drc"
  dummyPolyDRC = "/home/atd/tech/130nm/umc/dummy_slot/curr/L130_beyond_diffusion_poly1/130beyond_DIFFUSION_POLY1_dummy.drc"


  ## OUTPUT dummy GDS files generated by Calibre (Do NOT change)
  dummyGDS = "#{topCellName}_polydmy.gds"

  ## process raw drc file and generate final drc file (Do NOT change)
  finalDRC = "#{topCellName}_polydmy.drc"
  dummyDRCarr << finalDRC
  ff = File.new(finalDRC, "w")
  
  get_lines(dummyPolyDRC).each_with_index do |line, line_no|
    line.gsub!(/^\s*LAYOUT\s+PATH\s+.*$/i, "LAYOUT PATH \"#{inGDS}\"")
    line.gsub!(/^\s*LAYOUT\s+PRIMARY\s+.*$/i, "LAYOUT PRIMARY \"#{topCellName}\"")
    line.gsub!(/^\s*DRC\s+RESULTS\s+DATABASE\s+.*$/i, "DRC RESULTS DATABASE \"#{dummyGDS}\" GDSII PSEUDO")
    line.gsub!(/^\s*DRC\s+SUMMARY\s+REPORT\s+.*$/i, "DRC SUMMARY REPORT \"#{dummyGDS}.sum\"")
    line.gsub!(/^\s*LAYOUT\s+WINDOW\s+.*PLEASE.*$/i, "LAYOUT WINDOW #{windowX1Y1X2Y2.join(' ')}")
    line.gsub!(/^\s*POLYGON\s+.*$/i, "POLYGON #{windowX1Y1X2Y2.join(' ')} BULKALL")
    line.gsub!(/^\s*LAYOUT\s+PATH2\s+.*$/i, "LAYOUT PATH2 \"#{dummyPolyGDS}\"")
    
    ff.print(line)
  end
    

  ## Generate rundrc script for dummy generation and check
  pp dummyDRCarr if @debug
  drcCommand = File.new(options[:rundrc], "w")
  dummyDRCarr.each do |x|
    drcCommand.print("calibre -drc #{x}\n")
  end
  
    
end # class
